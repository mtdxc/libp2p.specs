作者备注：

这基于libp2p pubsub关于流行病广播协议的早期研究草案，这被称为episub，一个可扩展的gossip路由优化：针对单源多播或少数固定源广播到某主题的一大堆客户端。

## 介绍

本文档提出了 FloodSub 协议的后继者。它基于以下论文提出了一个主题发布订阅协议：

1.  流行病广播树，2007 年（[PDF](http://www.gsd.inesc-id.pt/~ler/docencia/rcs1617/papers/srds07.pdf)，DOI：[10.1109/SRDS.2007.27](https://doi.org/10.1109/SRDS.2007.27)）
2.  HyParView：基于八卦的可靠广播的成员协议，2007（[PDF](http://asc.di.fct.unl.pt/~jleitao/pdf/dsn07-leitao.pdf)，DOI：[10.1109/DSN.2007.56](http://doi.org/10.1109/DSN.2007.56)）
3.  GoCast：用于快速可靠的群组通信的八卦增强覆盖多播，2005 ( [PDF](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.75.4811&rep=rep1&type=pdf) )

该协议实现了 [1] 中的 Plumtree 算法，使用 HyParView [2] 管理成员资格，并基于 GoCast [3] 建议的方案构建proximity-aware邻近感知覆盖网。Plumtree 的原作者在 [1] 中也建议将 GoCast 的邻近感知与 Plumtree 结合。

该协议有两个不同的组件：成员管理协议（订阅）和广播协议（发布）。

成员管理协议（[1] 中的 Peer Sampling Service）维护两个订阅主题的节点列表。_活动_ 列表包含有活动广播连接的节点。_被动_ 列表是整个覆盖网的局部视图，用于指导新节点加入、替换活动列表中的失败节点和优化覆盖网。活动列表是对称的，这意味着如果节点 P 的活动列表中有节点 Q，则在 Q 的活动列表中也有 P。

广播协议使用"流行病广播"延迟构建和优化多播树。对等点将活动列表分成两组节点：_eager_ 节点和 _lazy_ 节点。eager节点形成多播树的边，而lazy节点形成支持多播树的八卦网。

当广播新消息时，消息被推送给eager节点，而lazy节点只接受消息摘要，并要求拉取丢失消息。最初，活动列表中的所有节点形成一个eager连接的网格。随着消息的传播，节点在收到重复消息时会 _裁剪_ eager连接，由此构建多播树。当节点接收到不是由eager连接传来的lazy消息时，通过在lazy连接之上 _嫁接_ 一个eager连接，来修复多播树。

在稳定状态下，协议以两种方式优化多播树：每当通过eager连接收到消息和lazy连接收到消息摘要时，都会比较其跳数hoop。当eager传输跳数减去lazy跳数超过某个阈值时，lazy连接可以代替eager连接作为树边，以减少由跳数测量到的延迟。此外，主动节点可能被更近的被动节点定期替换，从而及时减少传播延迟。

## 成员管理协议

### ViewSize的设计参数

活动和被动列表的大小是 HyParView 中的一个设计参数，取决于覆盖网的大小`N`：

```
A(N) = log(N) + c
P(N) = k * A(N)
```

[2] 中的作者选择`c=1`和`k=6`，同时将 N 固定为 10,000 节点。从长远来看，成员列表的大小应该根据覆盖网大小进行动态调整。出于实际目的，我们可以较大的目标大小为开始，在今后开发中引入动态大小调整。

须调整的第二个参数是 A 中用于邻近优化的随机和附近邻居的数量。在 [3] 中，作者使用两个参数`C_rand`和`C_near`来设置邻居列表的大小，使得

```
A = C_rand + C_near
```

在他们的分析中，他们固定`C_rand=1`和`C_near=5`，其基本原理是单个随机连接足以连接叠加层，至少在双峰八卦中是这样的。当没有随机连接，覆盖网可能因分片而无法连接。尽管如此，随机连接参数与覆盖层的连通性直接相关。更高的`C_rand`确保连接具有高概率和容错。HyParView 的容错和连通性源于随机覆盖结构，为了保留它们、并仍对接近度进行优化，我们须设置：

```
C_rand = log(N)
```

基于 IPFS 规模的真实案例，我们可以使用以下初始值：

```
N = 10,000
C_rand = log(N) = 4
C_near = c = 3
A = C_rand + C_near = log(N) + c = 7
P = k * A = 42
```

### 加入网络

为了订阅主题，节点 P 需要定位主题中的一个或多个节点并加入覆盖网。
初始联系节点可通过与 DHT 提供者记录会合rendezvous取得。

一旦获取到初始联系节点列表，节点随机选择节点并发送`GETNODES`消息，为了从订阅节点的被动列表中，获取覆盖网的最新视图，而忽略提供者记录的age。一旦获取到覆盖网的最新被动视图，节点会继续加入。

为了加入，它随机选择`C_rand`个节点并向它们发送`JOIN`消息，并携带一个初始的 TTL 设计参数。

`JOIN`消息以随机游走方式传播，直到遇到愿意接受它的节点或 TTL 到期。
收到`JOIN`消息后，节点 Q 根据以下标准对其进行评估：
- Q 反向连接 P 。如果无法连接（如在NAT后），则它会检查消息TTL:
  - 如为 0，则请求被丢弃；
  - 否则 递减 TTL 并将消息转发到其活动列表中的随机节点。
- 如请求 TTL 为 0 或 Q 的活动列表小于`A`，则它接受加入: 将 P 添加到其活动列表，并发送一个`NEIGHBOR`消息。
- 否则递减 TTL 并将消息转发到其活动列表中的随机节点。

当 Q 接受 P 为新的邻居时，它还会向活动列表中的随机节点发送`FORWARDJOIN`消息。`FORWARDJOIN`消息随机游走传播直到TTL 为 0，并将P加到接收节点的被动列表中。

如果 P 由于连接问题不能加入Join成功，它会递减 TTL 并尝试另一个起始节点。在 NATed 情况下，重复此操作，直到 TTL 为零而重用当前连接。

一旦建立了第一个连接，P 需要过连接到更多节点，来增加其活动列表的大小到`A`。这通过对订阅者列表按 RTT进行排序，然后选择最近的节点发送`NEIGHBOR`请求来实现。`NEIGHBOR`请求可通过`NEIGHBOR`消息来接受或用`DISCONNECT`消息来拒绝。

收到`NEIGHBOR`请求后，节点 Q 使用以下准则对其进行评估：
- 如 Q 的活动列表小于 A，则接受新节点。
- 如 P 的活动连接不够（小于`C_rand`，在消息中指定），它接受 P 作为随机邻居。
- 否则(Q活动列表够，P的随机邻居够，判断能否做近邻)，Q 对 P 进行 RTT 测量。如 P 的 RTT 比 Q 的任何近邻都还小 alpha 倍，那么 Q 会驱逐有足够活动连接的近邻，并接受 P 为新的近邻。
- 否则请求被拒绝。

注意：在连接期间，某些节点的活动列表可能会大于`A`。类似地，初始加入后，P 最终可能无法获取到`A`个活动连接。这遵循 [3] 并试图最小化连接时的抖动，并留给协议稳定期间的活动列表修剪(来处理)。

### 离开网络

为了取消订阅，节点可通过向其活动邻居发送`DISCONNECT`消息来离开覆盖网。本节点散布在覆盖网中的各种被动列表，会随着时间的推移，由协议的被动视图管理组件，对其进行lazy修剪。

为了能快速清理离开节点，我们也可在网络中引入一种急切传播的`LEAVE`消息：A节点想要取消订阅某主题，向其活动列表中的邻居发送`LEAVE`，而不是`DISCONNECT`。节点在收到`LEAVE`后，将A节点从其活动列表_和_被动列表中删除。如A节点已从列表之一中删除，或 TTL 大于零，`LEAVE`将在活动列表连接中进一步传播。这将确保通过网络随机扩散，急切地清除大部分活动列表，以牺牲一些带宽为代价。

### 活动视图管理

活动列表通常是被动管理的：通过检测TCP故障：无论是在发送消息时，还是检测到连接关闭时。

除了反应性/被动管理策略之外，活动列表还具有稳定和优化组件，由随机定时器周期触发，同时作为故障检测器。稳定组件尝试修剪比 A 大的活动列表，说是由于最近大量节点的加入；并增长比 A 小的活动列表，由于节点故障或之前无法获取足够多的邻居节点。
#### 减少活动列表
当一个节点检测到它的活动列表太大时，它查询活动列表中的邻居:
- 如某些邻居有超过`C_rand`个随机邻居，则可使用`DISCONNECT`消息丢弃连接，直到活动列表的大小再次为 A 为止。
- 如列表仍太大，则它检查活动列表以查找相互连接的邻居（三角连接）。在此情况下，可以用`DISCONNECT`消息删除其中的一个连接。
- 如列表仍太大，那么就不能安全地删除连接，将保持此大小直到下一个稳定期。
#### 增加活动列表
当节点检测到活动列表太小时，它会尝试通过从其被动列表中挑选节点来打开更多连接，如[加入网络](#加入网络)所述。
#### 优化Near连接
优化组件尝试用更近的节点替换连接来优化`C_near`连接。为此，它获取活动列表节点的RTT样本，并维护一个平滑的平均值。邻居按 RTT 重新排序，最近的邻居被当成是near节点。然后它检查被动列表节点的 RTT 采样样并选择最近的节点P。如果P的RTT比near节点小alpha倍，且用有足够的随机邻居，那么它将断开near连接，并使用被动列表中的新节点P为邻居。

### 被动视图管理

如[2]，被动列表管理由随机定时器周期触发的：每个节点与其活动邻居中的一个执行被动列表洗牌shuffle。洗牌目的是更新相关节点的被动列表。
发起洗牌的节点创建一个交换列表，包含自己的id、来自其活动列表的`k_a`个节点和来自其被动列表的`k_p`个节点，其中`k_a`和`k_p`是协议参数（在 [2] 中没指定）。然后它向一个随机邻居发送`SHUFFLE`请求，该请求进行 TTL 的随机游走传播。如果 TTL 大于 0 且接收方活动列表大于 1，则它会进一步传播请求。否则，节点从它的被动列表中随机选择节点，并发回一个`SHUFFLEREPLY`响应，然后用洗牌shuffe的内容替换它们。收到`SHUFFLEREPLY`消息的始发节点也用消息的内容替换其被动列表中的节点。
应注意由于 NAT 导致的传递连接问题：如果节点无法连接到原始节点，则不应执行洗牌; 类似地，发起节点可能会在等待shuffle回复时超时，此时应以减小TTL重试，直到 TTL 为零，在 NATed 主机的情况下重用当前连接。

除了洗牌之外，邻近感知和离开清理还要求计算 RTT 样本和检查与被动列表中节点的连通性。周期性地，节点从其被动列表中随机选择一些节点，并尝试打开一个连接（如还没有的话）。然后它检查节点是否仍订阅覆盖网。如果连接成功、且该节点仍订阅该主题，则会使用 ping 更新节点的 RTT 估计。否则，它将其从被动列表中删除以进行清理。

## 广播协议

### 广播状态

一旦它加入了覆盖层，节点就开始它的主广播逻辑循环。该循环接收要由应用层发出的消息、从其他节点发布的消息，以及来自管理协议的关于新的活动邻居和断开连接的通知。

广播循环的状态由两组节点组成，即eager列表和lazy列表，eager列表初始化为初始邻居，而lazy列表为空。该循环还维护一个基于时间的最近消息缓存，以及一个lazy消息通知队列。除了缓存之外，它还维护一个丢失消息列表，这些消息从lazy八卦了解到，但尚未通过多播树收到。

### 消息传播和多播树构造

当节点发布一条消息时，它向所有eager节点广播一个跳数为 1 的`GOSSIP`消息，将消息添加到缓存中，并将消息id加到lazy通知列表中。

当一个节点从邻居那里收到一条`GOSSIP`消息时，它首先检查缓存看是否已收过这条消息。如果消息在缓存中，它会通过向节点发送`PRUNE`消息来修剪多播图的边，并将源节点从eager列表移到lazy列表。

如果节点没有见过此消息，它会将消息传递给上层应用，并将节点添加到eager列表，然后继续广播：增加跳数，然后将消息转发给除了来源节点外的其他eager节点。它还将消息添加到缓存中，并将消息ID加到lazy通知列表中。

该循环运行一个短的定时器(周期为0.1秒)，用于八卦消息摘要。每当触发，节点都会将lazy通知列表刷到`IHAVE`消息中的最近收到消息ID字段，并发送给lazy节点。`IHAVE`通知总结了节点已看到、但未通过eager连接传播的最近消息。

### 组播树修复

当有错误产生时，至少有一个多播树的分支会受影响，此时消息不是通过 Eager Push 传输的。通过lazy八卦交换的`IHAVE`消息既用于恢复丢失消息，也用于提供一种快速机制来修复多播树。

当节点收到`IHAVE`中的未知消息时，它只是将消息标记为丢失并将它们放入丢失消息队列。然后它启动一个计时器，并期望在下次计时器到期之前，能通过eager连接收到该消息。计时器持续时间是一个协议参数，应根据覆盖的直径和目标恢复延迟进行配置。一个更现实的实现是使用持久定时器心跳来定期检查丢失的消息，在第一次触发时标记，并在第二次定时器触发时认为丢失。

当检测到一条消息丢失时，该节点会选择它收到的关于丢失消息的第一个`IHAVE`公告，并向公告方发送一条`GRAFT`消息，同时搭载其他丢失的消息。该`GRAFT`消息有双重目的：它触发丢失消息的传输，同时将连接添加到多播树，修复它。

收到`GRAFT`消息后，节点将对等方添加到eager列表中，并查找缓存将丢失消息以`GOSSIP`发出. 

请注意，不提前删除丢失消息列表，直到收到`GRAFT`消息的应答. 如果在下一个计时器过期前，还没有收到消息，比如说因嫁接的节点也失败了，那么将尝试另一个嫁接，依此类推，直到经过足够多的时间以认为消息丢失。

### 组播树优化

多播树是延迟构建的，起源于来自某个源的第一个发布消息的路径。因此，树可能不会重分利用新路径的优点，新路径由可能出现在覆盖图中的新节点/连接组成。除了第一个源之外，覆盖也可能不是最佳的。

为了克服这些限制并使覆盖网适应多个源，[1]的作者提出了一种优化：每收到一条消息，都检查丢失列表和列表中的消息跳数。如果eager传输跳数超过lazy传输的跳数，则树是可能的优化选。如果树是最优的，那么由eager推送收到的消息跳数应该小于或等于lazy推送传播的消息跳数。因此，eager连接可以由lazy连接代替，从而导致更短的树。

为了促进树的稳定性，[1] 中的作者建议仅当跳数的差异大于阈值时才执行此优化。该值是影响树整体稳定性的设计参数：值越低，协议越容易尝试通过交换连接来优化树。但是如果阈值太低，可能会导致多个主动源的颤动。因此，该值应该更高且更接近树的直径，以避免经常改变。

### 活动视图更改

对等活动列表由成员管理协议维护：节点可能会因为故障或覆盖网重组而被删除，新节点可能会因为新连接而添加到列表中。成员管理协议通过`NeighborUp`和`NeighborDown`通知将这些更改传给广播循环。

当有新节点加入活动列表时，广播循环收到`NeighborUp`通知；它只是将节点添加到eager列表中。另一方面，当通过`NeighborDown`通知删除节点时，循环必须考虑该节点是eager还是lazy节点。如果该节点是lazy节点，则不需要做任何事情，因为离开不会影响多播树。但如果该节点是一个eager的节点，则丢失的边可能导致树断开连接。

有两种策略可应对失去eager同伴的情况。
- 第一种是什么都不做，等待lazy推送`IHAVE`在下次消息广播时用消息自然修复树。这可能会导致延迟传播接下来的几条消息，但作者在 [1] 中提倡这样做。
- 另一种方法是通过紧急提升所有lazy节点到eager中，通过发送空`GRAFT`消息来紧急地修复树，并让协议在下一次消息传输中自然地用`PRUNE`消息修剪重复路径。这可能会产生一些带宽成本，但它可能更适合重视延迟最小化的应用程序，许多 IPFS 应用程序就是这种情况。

## 协议消息

以下是涉及到协议消息及其有效负载的快速摘要。假定所有消息都包含在合适的信封中，并具有源和单调递增的序列 ID。

```
;; Initial node discovery
GETNODES {}

NODES {
 peers []peer.ID
 ttl int
}

;; Topic querying (被动视图管理的成员检查)
GETTOPICS {}

TOPICS {
 topics []topic.ID
}

;; Membership Management protocol
JOIN {
 peer peer.ID
 ttl int
}

FORWARDJOIN {
 peer peer.ID
 ttl int
}

NEIGHBOR {
 # my neightbor peerId
 peers []peer.ID
}

DISCONNECT {}

LEAVE {
 source peer.ID
 ttl int
}

SHUFFLE {
 peer peer.ID
 peers []peer.ID
 ttl int
}

SHUFFLEREPLY {
 peers []peer.ID
}

;; Broadcast protocol
GOSSIP {
 source peer.ID
 hops int
 msg []bytes
}

IHAVE {
 summary []MessageSummary
}

MessageSummary {
 id message.ID
 hops int
}

PRUNE {}

GRAFT {
 # lost message id
 msgs []message.ID
}

```

## 与 Plumtree/HyParView 的区别

本文描述的协议和已发布的 Plumtree/HyParView 协议存在一些值得注意的差异。在小细节上可能有更多差异，但本文档是从实际实施者的角度来编写的。

成员管理协议：
- 节点视图通过邻近感知进行管理。HyParView 协议没有关于接近度的规定，这些来自 GoCast 的接近度感知覆盖网的实现；但请注意，我们不使用 UDP 进行 RTT 测量；增加的`C_rand`，以一些优化为代价，增加容错能力。
- 加入节点不会通过踢出现存节点来获得所有 A 连接，因为这会导致高流失率的覆盖网不稳定。相反，节点确保提前创建几个连接，即使会超额订阅扇出，但不会特意创建超出必要的`C_rand`个剩余连接。节点随后将活动列表通过稳定协议进行平衡。
值得注意的是，只有`C_rand`的`JOIN`消息采用随机游走传播；剩余的join被当是近邻加入，并用正常`NEIGHBOR`请求处理。
简而言之，在 GoCast 的影响下，Join 协议被重新设计。
- HyParView 中没有活动视图稳定/优化协议。这在很大程度上受到了 GoCast 的影响，该协议允许超额订阅，随后丢弃无关的连接和替换节点以进行邻近优化。
- `NEIGHBOR`消息在提议的协议实现中扮演着双重角色，它们可用于建立活动连接和检索成员列表。
- HyParView 中没有连接检查和减少TTL重试，但这在 NAT 的世界中非常重要。
- HyParView中没有`LEAVE`相关规定。

广播协议：
- `IHAVE`消息被聚合并通过后台定时器延迟推送。Plumtree 急切地推送`IHAVE`消息，既浪费又失去聚合的机会。尽管如此，作者确实建议将lazy聚合作为一种可能的优化。
- `GRAFT`消息同样聚合了多个丢失消息ID的请求。
- 丢失的消息和覆盖网修复由单个后台定时器管理，而不是为每条丢失的消息创建定时器；从实现的角度来看，这是不切实际的，至少在 Go 中是这样。
- Plumtree中没有对`NeighborDown`消息进行紧急覆盖网修复的规定。